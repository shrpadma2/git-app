<!DOCTYPE html>
<html>
  <head>
    <title>Clustered Network</title>
    <script src="./tableau.extensions.1.latest.js"></script>
    <script src="http://d3js.org/d3.v2.js"></script>

    <style type="text/css">
      svg {
        border: 1px solid #ccc;
      }
      body {
        font: 10px sans-serif;
      }
      circle.node {
        fill: lightsteelblue;
        stroke: #555;
        stroke-width: 3px;
      }
      circle.leaf {
        stroke: #fff;
        stroke-width: 1.5px;
      }
      path.hull {
        fill: lightsteelblue;
        fill-opacity: 0.3;
      }
      line.link {
        stroke: #333;
        stroke-opacity: 0.5;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <input type="text" id="nodeIdInput" placeholder="Enter node ID">
<button onclick="highlightNode()">Highlight Node</button>
<div id="jsonDataDisplay"></div>
<div id="debugArea" style="border:1px solid black; padding:10px; margin-top:10px; background-color: #f0f0f0;">
    <strong>Debug Area:</strong>
    <pre id="debugContent"></pre>
</div>

    <script type="text/javascript">
      var width = 960,     // svg width
        height = 600,     // svg height
        dr = 4,      // default point radius
        off = 15,    // cluster hull offset
        collapse = {}, // collapsed clusters
        data, net, force, hullg, hull, linkg, link, nodeg, node;

        var json_data = {
    nodes: [],
    links: []
};

      var curve = d3.svg.line()
        .interpolate("cardinal-closed")
        .tension(.85);

      var fill = d3.scale.category20();

      tableau.extensions.initializeAsync().then(function() {
            loadDataFromTableau();
        });

        function loadDataFromTableau() {
            const worksheetNodes = tableau.extensions.dashboardContent.dashboard.worksheets[0];
            const worksheetEdges = tableau.extensions.dashboardContent.dashboard.worksheets[1];

            worksheetNodes.getUnderlyingDataAsync().then(dataTableNodes => {
                let nodes = dataTableNodes.data.map(row => {
                    return {
                        name: row[0].formattedValue,
                        group: parseInt(row[1].formattedValue, 10)
                    };
                });

                worksheetEdges.getUnderlyingDataAsync().then(dataTableEdges => {
                    let links = dataTableEdges.data.map(row => {
                        return {
                            source: parseInt(row[1].formattedValue, 10), // Convert source to an integer
                            target: parseInt(row[0].formattedValue, 10), // Convert target to an integer
                            value: parseInt(row[2].formattedValue, 10) 
                        };
                    });

                    json_data.nodes = nodes; 
                    json_data.links = links;

                    data=json_data;
                    displayJsonData(data);
                    for (var i=0; i<data.links.length; ++i) {
                    o = data.links[i];
                    o.source = data.nodes[o.source];
                    o.target = data.nodes[o.target];
      }
                    
                    init();
                });
            });
        }
      
        function displayJsonData(jsonData) {
            var jsonDataDiv = document.getElementById('jsonDataDisplay');
            jsonDataDiv.innerHTML = '<h3>JSON Data</h3><pre>' + JSON.stringify(jsonData, null, 2) + '</pre>';
        }

      function noop() { return false; }

      function nodeid(n) {
        return n.size ? "_g_"+n.group : n.name;
      }

      function linkid(l) {
        var u = nodeid(l.source),
            v = nodeid(l.target);
        return u<v ? u+"|"+v : v+"|"+u;
      }

      function getGroup(n) { return n.group; }

      // constructs the network to visualize
      function network(data, prev, index, collapse) {
        collapse = collapse || {};
        var gm = {},    // group map
            nm = {},    // node map
            lm = {},    // link map
            gn = {},    // previous group nodes
            gc = {},    // previous group centroids
            nodes = [], // output nodes
            links = []; // output links

        // process previous nodes for reuse or centroid calculation
        if (prev) {
          prev.nodes.forEach(function(n) {
            var i = index(n), o;
            if (n.size > 0) {
              gn[i] = n;
              n.size = 0;
            } else {
              o = gc[i] || (gc[i] = {x:0,y:0,count:0});
              o.x += n.x;
              o.y += n.y;
              o.count += 1;
            }
          });
        }

        // determine nodes
        for (var k=0; k<data.nodes.length; ++k) {
          var n = data.nodes[k],
              i = index(n),
              l = gm[i] || (gm[i]=gn[i]) || (gm[i]={group:i, size:0, nodes:[]});

          if (collapse[i] !== true) {
            // the node should be directly visible
            nm[n.name] = nodes.length;
            nodes.push(n);
            if (gn[i]) {
              // place new nodes at cluster location (plus jitter)
              n.x = gn[i].x + Math.random();
              n.y = gn[i].y + Math.random();
            }
          } else {
            // the node is part of a collapsed cluster
            if (l.size == 0) {
              // if new cluster, add to set and position at centroid of leaf nodes
              nm[i] = nodes.length;
              nodes.push(l);
              if (gc[i]) {
                l.x = gc[i].x / gc[i].count;
                l.y = gc[i].y / gc[i].count;
              }
            }
            l.nodes.push(n);
          }
          // always count group size as we also use it to tweak the force graph strengths/distances
          l.size += 1;
          n.group_data = l;
        }

        for (i in gm) { gm[i].link_count = 0; }

        // determine links
        for (k=0; k<data.links.length; ++k) {
          var e = data.links[k],
              u = index(e.source),
              v = index(e.target);
          if (u != v) {
            gm[u].link_count++;
            gm[v].link_count++;
          }
          u = !collapse[u] ? nm[e.source.name] : nm[u];
          v = !collapse[v] ? nm[e.target.name] : nm[v];
          var i = (u<v ? u+"|"+v : v+"|"+u),
              l = lm[i] || (lm[i] = {source:u, target:v, size:0});
          l.size += 1;
        }
        for (i in lm) { links.push(lm[i]); }

        return {nodes: nodes, links: links};
      }

      function convexHulls(nodes, index, offset) {
        var hulls = {};

        // create point sets
        for (var k=0; k<nodes.length; ++k) {
          var n = nodes[k];
          if (n.size) continue;
          var i = index(n),
              l = hulls[i] || (hulls[i] = []);
          l.push([n.x-offset, n.y-offset]);
          l.push([n.x-offset, n.y+offset]);
          l.push([n.x+offset, n.y-offset]);
          l.push([n.x+offset, n.y+offset]);
        }

        // create convex hulls
        var hullset = [];
        for (i in hulls) {
          hullset.push({group: i, path: d3.geom.hull(hulls[i])});
        }

        return hullset;
      }

      function drawCluster(d) {
        return curve(d.path); // 0.8
      }

      function updateDebugArea(message) {
    var debugArea = document.getElementById("debugContent");
    debugArea.textContent += message + "\n";
}

      // --------------------------------------------------------

      var body = d3.select("body");

      var vis = body.append("svg")
         .attr("width", width)
         .attr("height", height);


      hullg = vis.append("g");
      linkg = vis.append("g");
      nodeg = vis.append("g");
      
      var zoom = d3.behavior.zoom()
    .scaleExtent([0.5, 10]) // Example scale extent
    .on("zoom", zoomed);

// Function to handle zoom event
function zoomed() {
  // Apply the transform to the group containing the nodes and links
  hullg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
  linkg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
  nodeg.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
}

// Apply the zoom behavior to the SVG element
vis.call(zoom);
      



 
      
var linkedByIndex = {};
// Initialize the index for direct and inverse links
data.links.forEach(function(d) {
  linkedByIndex[d.source.index + "," + d.target.index] = true;
  linkedByIndex[d.target.index + "," + d.source.index] = true;
});

function highlightNodesAndLinks(d, highlight) {
  // Reset styles for all nodes and links to default
  node.style("stroke", "#555").style("stroke-width", 3);
  link.style("stroke", "#333").style("stroke-opacity", 0.5);

  if (highlight) {
    // Highlight directly connected nodes
    node.each(function(o) {
      var thisNode = d3.select(this);
      var connected = isConnected(d, o);
      thisNode.style("stroke", connected ? "red" : "#555")
              .style("stroke-width", connected ? 4 : 3);
    });

    // Highlight directly connected links
    link.style("stroke", function(o) {
      return o.source === d || o.target === d ? "red" : "#333";
    }).style("stroke-opacity", function(o) {
      return o.source === d || o.target === d ? 1 : 0.5;
    });
  } else {
    // Reset styles to original state
    node.style("stroke", "#555").style("stroke-width", 3);
    link.style("stroke", "#333").style("stroke-opacity", 0.5);
  }
}

// Utilize the existing isConnected function
function isConnected(a, b) {
  return linkedByIndex[a.index + "," + b.index] || a.index === b.index;
}

      
function highlightNode() {
  // Log the selector to ensure it's what you expect
  var nodeId = document.getElementById("nodeIdInput").value.trim();
  var selector = "#node" + nodeId;
  console.log("Selector:", selector); // Check this in your browser's console

  // Attempt to select and highlight the node
  var node = d3.select(selector);
  console.log("Node selected:", node.node()); // This should log the SVG circle element if found

  // If the node is found, highlight it
  if (!node.empty()) {
    node.style("fill", "orange");
  } else {
    console.log("No node found with the ID:", selector);
  }
}


      function init() {
        

        if (force) force.stop();

        net = network(json_data, net, getGroup, collapse);

        force = d3.layout.force()
            .nodes(net.nodes)
            .links(net.links)
            .size([width, height])
            
          .linkStrength(function(l, i) {
          return 1;
          })
          .gravity(0.05)   // gravity+charge tweaked to ensure good 'grouped' view (e.g. green group not smack between blue&orange, ...
          .charge(-600)    // ... charge is important to turn single-linked groups to the outside
          .friction(0.5)   // friction adjusted to get dampened display: less bouncy bouncy ball [Swedish Chef, anyone?]
            .start();

        hullg.selectAll("path.hull").remove();
        hull = hullg.selectAll("path.hull")
            .data(convexHulls(net.nodes, getGroup, off))
          .enter().append("path")
            .attr("class", "hull")
            .attr("d", drawCluster)
            .style("fill", function(d) { return fill(d.group); })
            .on("click", function(d) {
             console.log("hull click", d, arguments, this, collapse[d.group]);
             collapse[d.group] = true; 
             init();
             
          });

        link = linkg.selectAll("line.link").data(net.links, linkid);
        link.exit().remove();
        link.enter().append("line")
            .attr("class", "link")
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; })
            .style("stroke-width", function(d) { return d.size || 1; })
        .on("mouseover", function(d) { highlightNodesAndLinks(d, true); })
    .on("mouseout", function(d) { highlightNodesAndLinks(d, false); });

        node = nodeg.selectAll("circle.node").data(net.nodes, nodeid);
        node.exit().remove();
        node.enter().append("circle")
            // if (d.size) -- d.size > 0 when d is a group node.
            .attr("class", function(d) { return "node" + (d.size?"":" leaf"); })
        .attr("id", function(d) { return"node" +d.name; })
            .attr("r", function(d) { return d.size ? d.size + dr : dr+1; })
            .attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; })
        .each(function(d) { console.log(this.id); })
            .style("fill", function(d) { return fill(d.group); })
        .on("mouseover", function(d) { highlightNodesAndLinks(d, true); })
    .on("mouseout", function(d) { highlightNodesAndLinks(d, false); })
    .on("click", function(d) { highlightNodesAndLinks(d, true); })
            .on("click", function(d) {
            console.log("node click", d, arguments, this, collapse[d.group]);
            collapse[d.group] = !collapse[d.group];
            init();
            });
        


        node.call(force.drag);

        force.on("tick", function() {
          if (!hull.empty()) {
            hull.data(convexHulls(net.nodes, getGroup, off))
                .attr("d", drawCluster);
          }

          link.attr("x1", function(d) { return d.source.x; })
              .attr("y1", function(d) { return d.source.y; })
              .attr("x2", function(d) { return d.target.x; })
              .attr("y2", function(d) { return d.target.y; });

          node.attr("cx", function(d) { return d.x; })
              .attr("cy", function(d) { return d.y; });
        });
      }

    </script>
  </body>
</html>
